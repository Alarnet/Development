Используя тестовые скрипты в Postman, вы можете проверить правильность работы API, сравнив результат с ожидаемым поведением или для отладки вывести какие либо значения после получения ответа от сервера.

Тестовые скрипты, также как и скрипты выполняемые перед запросом, можно добавлять не только к отдельным запросам, но и к коллекциям или папкам. Также в Postman есть готовые куски кода (code snippets) для стандартных задач, которые вы можете модифицировать под свои задачи.

Для добавления тестового скрипта к запросу вам потребуется открыть вкладку **Tests** и ввести туда свой код. Он будет запущен после выполнения запроса. Результат запуска тестовых скриптов будет доступен на вкладке **Test Results** ответа от сервера. В тестовых скриптах можно использовать динамические переменные. Добавлять проверки для данных из ответа и передавать полученные значения между запросами.

## Проверка ответа

В Postman есть несколько готовых сущностей, облегчающих проверку ответа:

- Для проверки данных, полученных в ответе мы можем использовать в скрипте `pm.response`.
- Создать тесты можно с помощью функции `pm.test`. Первый параметр - это строка, которая будет отображена в результатах выполнения теста. Во втором параметре передается функция, которая возвращает true или false. При значение true, тест отмечается как успешно выполненный. При значении false тест считается упавшим с ошибкой.
- Еще один способ добавления проверки в скрипт - `pm.expect`.

Давайте создадим новый тестовый скрипт и добавим в него несколько проверок для полученного ответа. Проверки будем делать для запроса:

`GET` https://postman-echo.com/delay/:delay

Добавим в коллекцию новую переменную delay и зададим ей значение 2.

Будем использовать ее в качестве path параметра для нашего запроса. Откроем вкладку **Tests**. Добавим следующий код:

```JSON
pm.test("Check status", function() {
    pm.response.to.have.status(200)
});

pm.test("Check delay", function() {
    pm.expect(pm.response.json().delay).to.equal(pm.collectionVariables.get("delay"));    
});
```

В первом вызове pm.test, мы проверяем что код ответа равен 200. Во втором проверяем, что в теле ответа значение delay, совпадает со значением переменной коллекции, которую мы использовали при отправке запроса. Давайте нажмем кнопку *Send* и выполним наш запрос. Затем откроем вкладку **Test Results**.

Возле названия вкладки мы видим количество тестов прошедших успешно, а также общее количество тестов. На самой вкладке мы видим результат выполнения тестов. Также доступны фильтры, для показа :
- всех тестов,
- только успешных,
- только упавших
- только пропущенных.

Давайте поменяем ожидаемое значение в первой проверке на 201 и снова выполним запрос.

Как мы и ожидали, первая проверка упала, т.к. ожидаемый код ответа не соответствует полученному. Сама проверка теперь отмечена красным цветом. Детали ошибки доступны, рядом с описанием.

Postman содержит набор готовых сниппетов, для часто встречающихся задач. Они находятся справа от редактора тестовых скриптов.

Среди них есть например получение, установка и очистка значений переменных, проверка кода, заголовков и тела ответа и другие часто используемые проверки. Для использования, просто нажмите на название нужного сниппета и он появится в редакторе. Вам останется лишь модифицировать его под свой случай использования. Использование сниппетов ускорит ваш процесс написания тестовых скриптов.

## Скрипты для коллекций и папок

Тестовые скрипты можно добавлять не только к отдельным запросам, но и на уровне папок и коллекций. Скрипт добавленный для коллекции, будет запущен после выполнения каждого запроса, из этой коллекции. Скрипт добавленный на уровне папки, будет запущен после каждого запроса, находящегося в этой папке. Такой механизм позволяет удобно организовать часто используемые скрипты. Порядок запуска  такой: сначала запускаются скрипты определенные
- на уровне коллекции,
- на уровне папки,
- на уровне запроса.

Чтобы добавлять или редактировать скрипты для коллекции, нужно выбрать нужную коллекцию и перейти на вкладку **Tests**. Для папки все аналогично. Давайте посмотрим, как выглядит отчет со скриптами, добавленными на разных уровнях.

Создадим новую коллекцию, назовем ее Postman Demo. В ней создадим новую папку, с именем Folder Demo. Внутри папки добавим два запроса:


`GET`	https://postman-echo.com/get?name={{name}}  
`POST` https://postman-echo.com/post?name={{name}}

На уровне коллекции добавим переменную **name** со значением **anna** и переменную **delay**, значение которой будет равно **2**. Внутри коллекции добавим еще один запрос :

`GET`	https://postman-echo.com/delay/:delay

Параметр *delay* будет задаваться из переменной коллекции с таким же именем. Теперь давайте добавим скрипт на уровне последнего GET запроса:

```JSON
pm.test("Check delay", function() {
    pm.expect(pm.response.json().delay).to.equal(pm.collectionVariables.get("delay"));    
});
```

Еще один тестовый скрипт будет на уровне папки. Он будет запущен только для двух запросов, которые находятся в этой папке:

```JSON
pm.test("Check name", function() {
    pm.expect(pm.response.json().args.name).to.equal("anna");    
});
```

Последний тестовый скрипт добавим на уровне коллекции. Он будет запущен для всех трех запросов:

```JSON
pm.test("Check status", function() {
    pm.response.to.have.status(200)
});
```

Запустим всю коллекцию.

Для каждого из запросов видим запуски тестовых скриптов. Для первого и второго запросов, находящихся в папке *Folder Demo*, сначала выполнились тестовые скрипты, заданные на уровне **коллекции**, затем на уровне **папки**. Третий скрипт не находится в папке, поэтому для него выполнился скрипт уровня **коллекции** и скрипт, который мы задавали для самого **запроса**.
